import { BaseService } from './base-service';
import { SlackBlock, SlackResponse } from '../types/slack.types';

/**
 * Service for formatting responses into Slack Block Kit format
 * Converts agent responses to rich, interactive Slack messages
 */
export class SlackFormatterService extends BaseService {
  
  constructor() {
    super('SlackFormatterService');
  }

  protected async onInitialize(): Promise<void> {
    this.logInfo('Slack formatter service initialized');
  }

  protected async onDestroy(): Promise<void> {
    this.logInfo('Slack formatter service destroyed');
  }

  /**
   * Format a simple text message
   */
  formatTextMessage(text: string): SlackResponse {
    return {
      text,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text
          }
        }
      ]
    };
  }

  /**
   * Format error message
   */
  formatErrorMessage(error: string): SlackResponse {
    return {
      text: `‚ùå Error: ${error}`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `‚ùå *Error*\n${error}`
          }
        }
      ]
    };
  }

  /**
   * Format help message
   */
  formatHelpMessage(): SlackResponse {
    return {
      text: 'AI Assistant Help',
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: 'ü§ñ AI Assistant Help'
          }
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: 'I can help you with:'
          }
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: 'üìß *Email Management*\n‚Ä¢ Check your inbox\n‚Ä¢ Send emails\n‚Ä¢ Search messages\n‚Ä¢ Draft responses'
          }
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: 'üìÖ *Calendar Management*\n‚Ä¢ Schedule meetings\n‚Ä¢ Check availability\n‚Ä¢ Create events\n‚Ä¢ Send invitations'
          }
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: 'üë§ *Contact Management*\n‚Ä¢ Find contacts\n‚Ä¢ Look up information\n‚Ä¢ Add new contacts'
          }
        },
        {
          type: 'divider'
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*Examples:*\n‚Ä¢ `/assistant check my email`\n‚Ä¢ `/assistant schedule meeting with John tomorrow at 2pm`\n‚Ä¢ `/assistant find contact for Jane Smith`'
          }
        }
      ]
    };
  }

  /**
   * Format email summary
   */
  formatEmailSummary(emails: any[]): SlackResponse {
    if (!emails.length) {
      return {
        text: 'No emails found',
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: 'üìß *Inbox Summary*\n\nNo new emails found.'
            }
          }
        ]
      };
    }

    const blocks: SlackBlock[] = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üìß Inbox Summary (${emails.length} emails)`
        }
      }
    ];

    emails.slice(0, 5).forEach((email, index) => {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*${email.subject || 'No Subject'}*\nFrom: ${email.from}\n${this.truncateText(email.snippet || '', 100)}`
        },
        accessory: {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'Read'
          },
          action_id: `read_email_${email.id}`,
          value: email.id
        }
      });

      if (index < emails.length - 1) {
        blocks.push({ type: 'divider' });
      }
    });

    if (emails.length > 5) {
      blocks.push({
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `And ${emails.length - 5} more emails...`
          }
        ]
      });
    }

    return {
      text: `Found ${emails.length} emails`,
      blocks
    };
  }

  /**
   * Format calendar events
   */
  formatCalendarEvents(events: any[]): SlackResponse {
    if (!events.length) {
      return {
        text: 'No events found',
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: 'üìÖ *Calendar*\n\nNo upcoming events found.'
            }
          }
        ]
      };
    }

    const blocks: SlackBlock[] = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üìÖ Upcoming Events (${events.length})`
        }
      }
    ];

    events.slice(0, 5).forEach((event, index) => {
      const startTime = new Date(event.start?.dateTime || event.start?.date);
      const endTime = new Date(event.end?.dateTime || event.end?.date);
      
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*${event.summary || 'No Title'}*\nüìÖ ${this.formatDate(startTime)} ‚Ä¢ ${this.formatTime(startTime)} - ${this.formatTime(endTime)}\n${event.description ? this.truncateText(event.description, 100) : ''}`
        },
        accessory: {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'View'
          },
          action_id: `view_event_${event.id}`,
          value: event.id
        }
      });

      if (index < events.length - 1) {
        blocks.push({ type: 'divider' });
      }
    });

    if (events.length > 5) {
      blocks.push({
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `And ${events.length - 5} more events...`
          }
        ]
      });
    }

    return {
      text: `Found ${events.length} events`,
      blocks
    };
  }

  /**
   * Format contact information
   */
  formatContactInfo(contacts: any[]): SlackResponse {
    if (!contacts.length) {
      return {
        text: 'No contacts found',
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: 'üë§ *Contacts*\n\nNo matching contacts found.'
            }
          }
        ]
      };
    }

    const blocks: SlackBlock[] = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üë§ Contacts (${contacts.length})`
        }
      }
    ];

    contacts.slice(0, 3).forEach((contact, index) => {
      const name = contact.names?.[0]?.displayName || 'Unknown';
      const email = contact.emailAddresses?.[0]?.value || '';
      const phone = contact.phoneNumbers?.[0]?.value || '';
      
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*${name}*\n${email ? `üìß ${email}\n` : ''}${phone ? `üìû ${phone}` : ''}`
        },
        accessory: {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'Details'
          },
          action_id: `view_contact_${contact.resourceName}`,
          value: contact.resourceName
        }
      });

      if (index < contacts.length - 1) {
        blocks.push({ type: 'divider' });
      }
    });

    if (contacts.length > 3) {
      blocks.push({
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `And ${contacts.length - 3} more contacts...`
          }
        ]
      });
    }

    return {
      text: `Found ${contacts.length} contacts`,
      blocks
    };
  }

  /**
   * Format confirmation message with actions
   */
  formatConfirmationMessage(message: string, confirmAction: string, cancelAction?: string): SlackResponse {
    const elements: any[] = [
      {
        type: 'button',
        text: {
          type: 'plain_text',
          text: 'Confirm'
        },
        style: 'primary',
        action_id: confirmAction,
        value: 'confirm'
      }
    ];

    if (cancelAction) {
      elements.push({
        type: 'button',
        text: {
          type: 'plain_text',
          text: 'Cancel'
        },
        action_id: cancelAction,
        value: 'cancel'
      });
    }

    return {
      text: message,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: message
          }
        },
        {
          type: 'actions',
          elements
        }
      ]
    };
  }

  /**
   * Format success message
   */
  formatSuccessMessage(message: string): SlackResponse {
    return {
      text: `‚úÖ ${message}`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `‚úÖ *Success*\n${message}`
          }
        }
      ]
    };
  }

  /**
   * Format loading message
   */
  formatLoadingMessage(action: string): SlackResponse {
    return {
      text: `‚è≥ ${action}...`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `‚è≥ ${action}...`
          }
        }
      ]
    };
  }

  /**
   * Utility: Truncate text to specified length
   */
  private truncateText(text: string, maxLength: number): string {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }

  /**
   * Utility: Format date
   */
  private formatDate(date: Date): string {
    return date.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric'
    });
  }

  /**
   * Utility: Format time
   */
  private formatTime(date: Date): string {
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
  }
}