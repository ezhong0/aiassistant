/**
 * Layer 1: Query Decomposer Service
 *
 * Transforms natural language queries into structured execution graphs.
 * Phase 1 implementation complete.
 */

import { BaseService } from '../../services/base-service';
import { DecompositionInput, ExecutionGraph } from './execution-graph.types';
import { AIDomainService } from '../../services/domain/ai-domain.service';
import { DecompositionPromptBuilder } from './decomposition-prompt-builder';
import { ExecutionGraphValidator } from './execution-graph-validator';
import { IntentExtractorService } from './intent-extractor.service';
import { QueryPlannerService } from './query-planner.service';
import { ErrorFactory } from '../../errors/error-factory';

export class QueryDecomposerService extends BaseService {
  private useIntentBasedPlanning: boolean;

  constructor(
    private aiService: AIDomainService,
    private decompositionPromptBuilder: DecompositionPromptBuilder,
    private executionGraphValidator: ExecutionGraphValidator,
    private intentExtractor: IntentExtractorService,
    private queryPlanner: QueryPlannerService
  ) {
    super('QueryDecomposerService');

    // Feature flag: Use new intent-based architecture
    // Set to true to use Intent Extractor + Query Planner (code-based)
    // Set to false to use old LLM-generates-everything approach
    this.useIntentBasedPlanning = process.env.USE_INTENT_PLANNER === 'true' || true;
  }

  /**
   * Service initialization
   */
  protected async onInitialize(): Promise<void> {
    this.logInfo('QueryDecomposerService initialized');
  }

  /**
   * Service cleanup
   */
  protected async onDestroy(): Promise<void> {
    this.logInfo('QueryDecomposerService destroyed');
  }

  /**
   * Decompose user query into execution graph
   * @param input - Query and context information
   * @returns Execution graph with dependencies and resource estimates
   */
  async decompose(input: DecompositionInput): Promise<ExecutionGraph> {
    const startTime = Date.now();

    console.log('\n\n========================================');
    console.log('🔍 DEBUG: decompose() called');
    console.log('🔍 DEBUG: useIntentBasedPlanning =', this.useIntentBasedPlanning);
    console.log('🔍 DEBUG: process.env.USE_INTENT_PLANNER =', process.env.USE_INTENT_PLANNER);
    console.log('========================================\n');

    this.logInfo('Decomposing query', {
      query: input.user_query.substring(0, 100),
      historyLength: input.conversation_history.length,
      hasUserContext: !!input.user_context
    });

    try {
      // Validate input
      this.validateInput(input);

      // Choose decomposition approach
      let graph: ExecutionGraph;

      if (this.useIntentBasedPlanning) {
        // NEW APPROACH: Intent extraction + code-based planning
        console.log('\n🔍 DEBUG: Using intent-based query planning (code-generated graph)');
        this.logInfo('Using intent-based query planning (code-generated graph)');

        try {
          console.log('🔍 DEBUG: Calling IntentExtractor...');
          // Step 1: Extract intent (LLM - simple semantic understanding)
          const intentResult = await this.intentExtractor.extractIntent(input);
          console.log('🔍 DEBUG: Intent extracted successfully:', JSON.stringify(intentResult.intent, null, 2));
          this.logInfo('Intent extracted', {
            action: intentResult.intent.action,
            criteriaCount: intentResult.intent.criteria.length,
            confidence: intentResult.confidence
          });

          console.log('🔍 DEBUG: Calling QueryPlanner...');
          // Step 2: Plan execution (CODE - deterministic graph generation)
          graph = this.queryPlanner.planExecution(intentResult.intent);
          console.log('🔍 DEBUG: Execution graph generated. Node count:', graph.information_needs.length);
          console.log('🔍 DEBUG: First node filters:', JSON.stringify(graph.information_needs[0]?.strategy?.params?.filters, null, 2));
          this.logInfo('Execution graph generated by query planner', {
            nodeCount: graph.information_needs.length,
            llmCalls: graph.resource_estimate.total_llm_calls
          });
        } catch (error: any) {
          console.error('❌ DEBUG: Intent-based planning failed!', error);
          console.error('❌ DEBUG: Error message:', error.message);
          console.error('❌ DEBUG: Error stack:', error.stack);
          this.logError('Intent-based planning failed, falling back to LLM approach', error);
          // Fall back to old approach if new one fails
          console.log('🔄 DEBUG: Falling back to old LLM approach...');
          graph = await this.decompositionPromptBuilder.execute(input);
        }
      } else {
        // OLD APPROACH: LLM generates entire execution graph
        this.logInfo('Using LLM-based query decomposition (legacy)');
        graph = await this.decompositionPromptBuilder.execute(input);
      }

      // Validate the generated graph
      const validationResult = this.executionGraphValidator.validate(graph);

      if (!validationResult.valid) {
        this.logError('Generated execution graph is invalid', new Error('Invalid graph'), {
          errors: validationResult.errors,
          query: input.user_query.substring(0, 100)
        });
        throw ErrorFactory.domain.serviceError(
          'QueryDecomposer',
          `Invalid execution graph: ${validationResult.errors.join(', ')}`
        );
      }

      // Log warnings (but don't fail)
      if (validationResult.warnings.length > 0) {
        this.logWarn('Execution graph has warnings', {
          warnings: validationResult.warnings,
          query: input.user_query.substring(0, 100)
        });
      }

      const decompositionTime = Date.now() - startTime;

      this.logInfo('Query decomposed successfully', {
        query: input.user_query.substring(0, 100),
        queryType: graph.query_classification.type,
        complexity: graph.query_classification.complexity,
        nodeCount: graph.information_needs.length,
        parallelGroups: this.countParallelGroups(graph),
        estimatedTokens: graph.resource_estimate.estimated_tokens,
        decompositionTimeMs: decompositionTime
      });

      return graph;
    } catch (error) {
      this.logError('Failed to decompose query', error as Error, {
        query: input.user_query.substring(0, 100),
        error: error instanceof Error ? error.message : 'Unknown error'
      });

      throw error;
    }
  }

  /**
   * Validate decomposition input
   */
  private validateInput(input: DecompositionInput): void {
    if (!input.user_query || input.user_query.trim().length === 0) {
      throw ErrorFactory.api.badRequest('User query cannot be empty');
    }

    if (input.user_query.length > 5000) {
      throw ErrorFactory.api.badRequest('User query too long (max 5000 characters)');
    }

    if (!input.current_timestamp) {
      throw ErrorFactory.api.badRequest('Current timestamp required');
    }
  }

  /**
   * Count number of parallel groups in graph
   */
  private countParallelGroups(graph: ExecutionGraph): number {
    const groups = new Set(graph.information_needs.map(n => n.parallel_group));
    return groups.size;
  }

  /**
   * Health check for service
   */
  getHealth() {
    return {
      healthy: true,
      service: 'QueryDecomposerService',
      status: 'operational'
    };
  }
}

